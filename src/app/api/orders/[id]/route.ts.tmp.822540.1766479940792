import { NextRequest, NextResponse } from 'next/server'
import { createAdminClient } from '@/lib/supabase/admin'

interface RouteParams {
  params: Promise<{ id: string }>
}

// GET: 발주 상세 조회
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params
    const supabase = createAdminClient()

    // 발주서 조회
    const { data: order, error: orderError } = await supabase
      .from('ru_orders')
      .select('*')
      .eq('id', id)
      .single()

    if (orderError || !order) {
      return NextResponse.json(
        { error: '발주서를 찾을 수 없습니다.' },
        { status: 404 }
      )
    }

    // 발주 품목 조회
    const { data: items, error: itemsError } = await supabase
      .from('ru_order_items')
      .select('*')
      .eq('order_id', id)
      .order('created_at', { ascending: true })

    if (itemsError) {
      console.error('Order items fetch error:', itemsError)
    }

    return NextResponse.json({
      success: true,
      order: {
        ...order,
        items: items || []
      }
    })

  } catch (error) {
    console.error('Order detail API error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : '발주 조회 중 오류 발생' },
      { status: 500 }
    )
  }
}

// PATCH: 발주 수정
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params
    const body = await request.json()
    const supabase = createAdminClient()

    // 기존 발주 조회
    const { data: existing, error: existingError } = await supabase
      .from('ru_orders')
      .select('status, history')
      .eq('id', id)
      .single()

    if (existingError || !existing) {
      return NextResponse.json(
        { error: '발주서를 찾을 수 없습니다.' },
        { status: 404 }
      )
    }

    // 상태 검증: DRAFT, CONFIRMED만 수정 가능
    if (!['DRAFT', 'CONFIRMED'].includes(existing.status)) {
      return NextResponse.json(
        { error: `${existing.status} 상태에서는 수정할 수 없습니다.` },
        { status: 400 }
      )
    }

    // 업데이트 데이터 구성
    const updateData: Record<string, unknown> = {}

    if (body.destination !== undefined) updateData.destination = body.destination
    if (body.remarks !== undefined) updateData.remarks = body.remarks
    if (body.status !== undefined) updateData.status = body.status

    // 이력 추가
    const history = existing.history || []
    history.push({
      date: new Date().toISOString(),
      action: body.status ? `status_changed_to_${body.status}` : 'updated',
      by: body.updated_by || 'system',
      changes: body.changes_description || null
    })
    updateData.history = history

    // 발주 품목 업데이트
    if (body.items && Array.isArray(body.items)) {
      // 기존 품목 삭제
      await supabase.from('ru_order_items').delete().eq('order_id', id)

      // 새 품목 추가
      const newItems = body.items.map((item: {
        product_code: string
        product_name?: string
        qty: number
        supply_price: number
        commission: number
        unit_price: number
      }) => ({
        order_id: id,
        product_code: item.product_code,
        product_name: item.product_name || null,
        qty: item.qty,
        supply_price: item.supply_price,
        commission: item.commission,
        unit_price: item.unit_price,
        subtotal: item.unit_price * item.qty
      }))

      await supabase.from('ru_order_items').insert(newItems)

      // 합계 재계산
      updateData.total_qty = body.items.reduce((sum: number, item: { qty: number }) => sum + item.qty, 0)
      updateData.total_amount = body.items.reduce(
        (sum: number, item: { qty: number; unit_price: number }) => sum + (item.unit_price * item.qty),
        0
      )
    }

    // 발주서 업데이트
    const { data: updated, error: updateError } = await supabase
      .from('ru_orders')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (updateError) {
      console.error('Order update error:', updateError)
      return NextResponse.json(
        { error: '발주서 수정 실패' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      order: updated
    })

  } catch (error) {
    console.error('Order update API error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : '발주 수정 중 오류 발생' },
      { status: 500 }
    )
  }
}

// DELETE: 발주 삭제
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params
    const supabase = createAdminClient()

    // 기존 발주 조회
    const { data: existing, error: existingError } = await supabase
      .from('ru_orders')
      .select('status')
      .eq('id', id)
      .single()

    if (existingError || !existing) {
      return NextResponse.json(
        { error: '발주서를 찾을 수 없습니다.' },
        { status: 404 }
      )
    }

    // DRAFT 상태만 삭제 가능
    if (existing.status !== 'DRAFT') {
      return NextResponse.json(
        { error: 'DRAFT 상태의 발주서만 삭제할 수 있습니다.' },
        { status: 400 }
      )
    }

    // 발주 품목 삭제 (CASCADE로 자동 삭제되지만 명시적으로)
    await supabase.from('ru_order_items').delete().eq('order_id', id)

    // 발주서 삭제
    const { error: deleteError } = await supabase
      .from('ru_orders')
      .delete()
      .eq('id', id)

    if (deleteError) {
      console.error('Order delete error:', deleteError)
      return NextResponse.json(
        { error: '발주서 삭제 실패' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: '발주서가 삭제되었습니다.'
    })

  } catch (error) {
    console.error('Order delete API error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : '발주 삭제 중 오류 발생' },
      { status: 500 }
    )
  }
}
